import firebase from "firebase/compat/app";
import "firebase/compat/firestore";
import 'firebase/firestore';
import { getPrice } from 'backend/yahoo-finance.jsw'
import { initializeApp } from 'firebase/app';

const firebaseConfig = {
  apiKey: "AIzaSyBiHEJip0aI_LnBBGgMM2ufxv_5MOfDlHo",
  authDomain: "investment-club-a702f.firebaseapp.com",
  projectId: "investment-club-a702f",
  storageBucket: "investment-club-a702f.appspot.com",
  messagingSenderId: "974519574723",
  appId: "1:974519574723:web:53107a56881743ef338276",
  measurementId: "G-RR6N02R821"
};

firebase.initializeApp(firebaseConfig);

let db = firebase.firestore();

export async function getDoc(docRef) {
    // the use of promise let us resolve the data when the asynchronous call is finished
    return new Promise(resolve => {
        docRef.get()
            .then(function (doc) { 
                // When the document is retrieved, this function returns the document's data
                resolve(doc.data());
            })
        })
}

export async function addTeam(contest, name, userId, data) {
    //get data
    let pwd = data.pwd;
    
    const userRef = db.doc("spring2023/Users/users/" + userId);
    let teamData = {"pwd": pwd, "portfolio": [], "history": [], "total_val": 100000, "cash": 100000, "bp": 100000, "name": name, "users": [userRef] };

    //add team to collection
    db.collection("spring2023/Contests/contests/" + contest + "/teams")  
        .add(teamData)
        .then(function(docRef) {
            userRef.set( { "team_list": { [contest]: docRef.id } }, { merge: true } );
        });
}

export async function addUserToTeam(contest, userId, teamId) {
    let userRef = db.doc("spring2023/Users/users/" + userId);
    let teamRef = db.doc("spring2023/Contests/contests/" + contest + "/teams/" + teamId);

    let team = await getDoc(teamRef);
    console.log(teamRef);
    let users = team.users;
    users.push(userRef);

    await userRef.set( { "team_list": { [contest]: teamRef.id } }, { merge: true } );
    await teamRef.update( { "users": users } )
}

export async function getTeamId(userId, contest) {
    let userRef = db.collection("spring2023/Users/users").doc(userId);
    let user = await getDoc(userRef);
    try {
        let teamId = user.team_list[contest];
        if (teamId === undefined) throw Error;
        return teamId;
    } catch(e) {
        return -1;
    }
}

export async function getTeamData(teamId, contest) {
    let teamRef = db.collection("spring2023/Contests/contests/" + contest + "/teams").doc(teamId);
    updatePortfolio(teamRef);
    let team = await getDoc(teamRef);
    return team;
}

export async function getRankData(contest) {
    let teamsRef = db.collection("spring2023/Contests/contests/" + contest +"/teams");
    let querySnapshot = await teamsRef.orderBy("total_val", "desc").get();
    let teams = querySnapshot.docs.map(doc => doc.data());

    let ret = [];
    let ind = 0;
    teams.forEach(function(doc) {
        ret.push({"Place": ++ind, "Name": doc.name, "total_val": doc.total_val})
    })
    return ret;
}

export async function updatePortfolio(teamRef, tradeTicker = "") {
    let team = await getDoc(teamRef);
    let cash = team.cash;
    let port = team.portfolio

    //calculate new asset value
    let total_asset = 0;

    //if trading, get index of ticker if exists
    let pos = -1;

    //go through port
    for (let i = 0; i < port.length; i++) {
        let curr = port[i];
        let qty = curr.qty;
        let ticker = curr.ticker;
        if (ticker == tradeTicker) {pos = i;}

        //get price from api
        let val = await getPrice(ticker);
        total_asset += qty*val;
    }

    //update total port value
    let new_total = cash + total_asset;
    teamRef.update({"total_val": new_total});
    return pos;
}

export async function trade(teamId, data) {
    //get data about trade
    let action = data.action;
    let contest = data.contest
    let ticker = data.ticker;
    let qty = data.qty;
    let date = data.date;
    let price = data.price;
    
    //get team from user
    let teamRef = db.collection("spring2023/Contests/contests/" + contest + "/teams").doc(teamId);
    let team = await getDoc(teamRef);

    //get team data
    let port = team.portfolio;
    let cash = team.cash;
    let bp = team.bp;
    let hist = team.history;

    //update team's portfolio, dont need to do this to get stock
    let pos = await updatePortfolio(teamRef, ticker);

    if (action == "Buy") {
        // if buy back
        if (pos != -1 && port[pos].qty < 0) {
            let cqty = -port[pos].qty;
            qty = Math.min(qty, cqty);
            bp += qty*price/2;
            cash -= qty*price;

            if (qty != cqty) port[pos] = {"qty": qty - cqty, "ticker": ticker, "trade_price": price, "date": date};
            else port.splice(pos, 1);
        } else {
            if (qty*price > bp) {
                qty = Math.floor(bp/price);
                if (qty == 0) return false; //add to front end
            }

            bp -= qty*price;
            cash -= qty*price;

            if (pos == -1) port.push({"qty": qty, "ticker": ticker, "trade_price": price, "date": date});
            else port[pos] = {"qty": qty + port[pos].qty, "ticker": ticker, "trade_price": price, "date": date}
        }
    } else {
        // selling smth i currently have (not short)
         if (pos != -1 && port[pos].qty > 0) {
            let cqty = port[pos].qty;
            qty = Math.min(qty, cqty);
            bp += qty*price;
            cash += qty*price;

            if (qty != cqty) port[pos] = {"qty": cqty - qty, "ticker": ticker, "trade_price": price, "date": date};
            else port.splice(pos, 1);
        } else {
            if (qty*price > bp) {
                qty = Math.floor(bp/price);
                if (qty == 0) return false;
            }

            bp -= qty*price/2;
            cash += qty*price;

            if (pos == -1) port.push({"qty": -qty, "ticker": ticker, "trade_price": price, "date": date});
            else port[pos] = {"qty": port[pos].qty -qty, "ticker": ticker, "trade_price": price, "date": date}
        }
    }
    
    //update data
    hist.push({"ticker": ticker, "qty": qty, "action": action, "date": date});
    teamRef.update({"bp": bp, "cash": cash, "portfolio": port, "history": hist});
    updatePortfolio(teamRef);

    return true;
}

export async function getTeams(contest) {
    let teamsRef = db.collection("spring2023/Contests/contests/" + contest + "/teams");
    let snapshot = await teamsRef.get();

    let ret = [];
    snapshot.forEach(doc => {
        let team = doc.data();
        ret.push({ "teamId": doc.id, "# of People": team.users.length, "Name": team.name, "pwd": team.pwd});
    })

    return ret;
}
